#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl5,  rightLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftLiftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl11, grabberEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  leftDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           rightDrive2,   tmotorVex393TurboSpeed_HBridge, PIDControl, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port2,           rightDrive,    tmotorVex393TurboSpeed_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port3,           leftDrive,     tmotorVex393TurboSpeed_MC29, PIDControl, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port4,           rightLift,     tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl5)
#pragma config(Motor,  port5,           leftLift,      tmotorVex393_MC29, openLoop, encoderPort, dgtl7)
#pragma config(Motor,  port6,           rightGrabber,  tmotorVex393_MC29, openLoop, encoderPort, dgtl11)
#pragma config(Motor,  port7,           leftGrabber,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightLift2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           leftLift2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          leftDrive2,    tmotorVex393TurboSpeed_HBridge, PIDControl, driveLeft, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// IME 627.2 counts per revolution
// 1 Revolution = 4Pi = 12.5663706
//


void move(int speed, int dir){
// dir == 1 forward
// dir == -1 backwards
	motor[leftDrive] = speed*dir;
	motor[leftDrive2] = speed*dir;
	motor[rightDrive] = speed*dir;
	motor[rightDrive2] = speed*dir;
}

void resetDrive (){
	motor[leftDrive] = 0;
	motor[leftDrive2] = 0;
	motor[rightDrive] = 0;
	motor[rightDrive2] = 0;

}

void resetEnc() {
	SensorValue[leftDriveEncoder] = 0;
	SensorValue[rightDriveEncoder] = 0;
	SensorValue[leftLiftEncoder] = 0;
	SensorValue[leftLiftEncoder] = 0;
}

void turn(int speed, int dir){
// dir == 1 CCW
// dir == -1 CW
	motor[leftDrive] = speed*(-dir);
	motor[leftDrive2] = speed*(-dir);
	motor[rightDrive] = speed*dir;
	motor[rightDrive2] = speed*dir;

}
void orient(int speed, int target){
// dir == 1 CCW
// dir == -1 CW

	int dir = (target - SensorValue[in8])/abs(target - SensorValue[in8])

	motor[leftDrive] = speed*(-dir);
	motor[leftDrive2] = speed*(-dir);
	motor[rightDrive] = speed*dir;
	motor[rightDrive2] = speed*dir;

}

void liftComp(int target){
	int correction = target - SensorValue[leftliftEncoder];
	if (SensorValue[leftLiftEncoder] < target) {
		motor[leftLift] = -1*(correction*correction);
		motor[leftLift2] = -1*(correction*correction);
		motor[rightLift] = -1*(correction*correction);
		motor[rightLift2] = -1*(correction*correction);
	}
	if (SensorValue[leftLiftEncoder] > target) {
		motor[leftLift] = correction*correction;
		motor[leftLift2] = correction*correction;
		motor[rightLift] = correction*correction;
		motor[rightLift2] = correction*correction;
	}
}

bool liftSimple(int target){
	int correction = target - SensorValue[leftliftEncoder];
	if (SensorValue[leftLiftEncoder] < target) {
		motor[leftLift] = -1*(correction*correction);
		motor[leftLift2] = -1*(correction*correction);
		motor[rightLift] = -1*(correction*correction);
		motor[rightLift2] = -1*(correction*correction);
		return false;
	}
	if (SensorValue[leftLiftEncoder] > target) {
		motor[leftLift] = correction*correction;
		motor[leftLift2] = correction*correction;
		motor[rightLift] = correction*correction;
		motor[rightLift2] = correction*correction;
		return true;
	}
	return false;
}

int grabber(int action, int type){
	int target;
	//Pick up
	if (action == 0) {
		//type == 0 Stars
		if (type == 0) {
			target = -930;
		}
		//type == 1 Cube
		if (type == 1){
			target = -800;
		}
	}
	//Drop
	if (action == 1){
		target = -450
	}
	return target
}

void checkGrip(int type){
	int target;
	//type == 0 Stars
	if (type == 0) {
		target = -930;
	}
	//type == 1 Cube
	if (type == 1){
		target = -870;
	}

	if(SensorValue[grabberEncoder] > target) {
		motor[leftGrabber] = 40;
		motor[rightGrabber] = 40;
	} else {
		motor[leftGrabber] = 0;
		motor[rightGrabber] = 0;
	}
}



task main()
{

	//Forward 27 inches
	// 780 * (627.2 / 360) = 1359
	while (SensorValue[leftDriveEncoder] <= 780){
		move(60, 1);
	}
	resetDrive();

	//CCW Turn 90 Degrees
	while (abs(SensorValue[in8]) < 600){
		turn(60, 1);
	}
	resetDrive();
	resetEnc();
	wait1Msec(300);

	//Forward 17 inches
	// 580  * (627.2 / 360) = 1010
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	resetDrive();

	//Grab cube
	while (SensorValue[grabberEncoder] > grabber(0, 1)) {
			motor[leftGrabber] = 127;
			motor[rightGrabber] = 127;
	}
	motor[leftGrabber] = 0;
	motor[rightGrabber] = 0;

	resetDrive();
	resetEnc();
	wait1Msec(300);

	//Backwards 17 inches
	while (abs(SensorValue[leftDriveEncoder]) <= 580) {
		move(60, -1);
		checkGrip(1);
	}
	resetDrive();
	resetEnc();
	wait1Msec(300);

	int turnTarget = (abs(SensorValue[in8])+300);
	//CCW Turn 90 Degrees
	while (abs(SensorValue[in8]) < turnTarget){
		turn(70, 1);
		checkGrip(1);
		if (SensorValue[leftLiftEncoder] < 20){
			motor[leftLift] = -90;
			motor[leftLift2] = -90;
			motor[rightLift] = -90;
			motor[rightLift2] = -90;
		} else {
			motor[leftLift] = 0;
			motor[leftLift2] = 0;
			motor[rightLift] = 0;
			motor[rightLift2] = 0;
		}
	}
	resetDrive();
	resetEnc();

	wait1Msec(400);
	/*
	//Backwards into fence
	while (abs(SensorValue[leftDriveEncoder]) <= 400) {
		move(60, -1);
		checkGrip(1);
	}*/

	while (/*SensorValue[leftLiftEncoder] < 195*/ liftSimple(145) == false) {
	//	liftComp(10);
		move(40, -1);
		checkGrip(1);
	}


	//Drop cube
	while (SensorValue[grabberEncoder] < -700) {
		if (SensorValue[leftLiftEncoder] < 145){
			motor[leftLift] = -90;
			motor[leftLift2] = -90;
			motor[rightLift] = -90;
			motor[rightLift2] = -90;
		} else {
			motor[leftLift] = 90;
			motor[leftLift2] = 90;
			motor[rightLift] = 90;
			motor[rightLift2] = 90;
		}
		motor[leftGrabber] = -127;
		motor[rightGrabber] = -127;
	}
	motor[leftGrabber] = 50;
	motor[rightGrabber] = 50;
	motor[leftLift] = 90;
	motor[leftLift2] = 90;
	motor[rightLift] = 90;
	motor[rightLift2] = 90;
	wait1Msec(200);
	motor[leftGrabber] = 0;
	motor[rightGrabber] = 0;
	motor[leftLift] = 0;
	motor[leftLift2] = 0;
	motor[rightLift] = 0;
	motor[rightLift2] = 0;


//End of Autonomous
	int i = 0;
	int driverLoad = 1;
	while(i < 4){ //Driver Load loop
	while (SensorValue[in8] != 1800){
		orient(80, 1800);
	}
	resetDrive();
	resetEnc();
	wait1Msec(300);

	//Change distance
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	resetDrive();
	if (i == 2){
		driverLoad = 0;
	}
	//Grab Driver Load
	while (SensorValue[grabberEncoder] > grabber(0, driverLoad)) {
			motor[leftGrabber] = 127;
			motor[rightGrabber] = 127;
	}
	motor[leftGrabber] = 0;
	motor[rightGrabber] = 0;

	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, -1);
		checkGrip(driverLoad);
	}
	resetDrive();

	while (/*SensorValue[leftLiftEncoder] < 195*/ liftSimple(145) == false) {
	//	liftComp(10);
		move(60, -1); // Adjust speed for timing
		checkGrip(driverLoad);
	}


	//Drop cube
	while (SensorValue[grabberEncoder] < -700) {
		if (SensorValue[leftLiftEncoder] < 145){
			motor[leftLift] = -90;
			motor[leftLift2] = -90;
			motor[rightLift] = -90;
			motor[rightLift2] = -90;
		} else {
			motor[leftLift] = 90;
			motor[leftLift2] = 90;
			motor[rightLift] = 90;
			motor[rightLift2] = 90;
		}
		motor[leftGrabber] = -127;
		motor[rightGrabber] = -127;
	}
	motor[leftGrabber] = 50;
	motor[rightGrabber] = 50;
	motor[leftLift] = 90;
	motor[leftLift2] = 90;
	motor[rightLift] = 90;
	motor[rightLift2] = 90;
	wait1Msec(200);
	motor[leftGrabber] = 0;
	motor[rightGrabber] = 0;
	motor[leftLift] = 0;
	motor[leftLift2] = 0;
	motor[rightLift] = 0;
	motor[rightLift2] = 0;
	i++;
	}
	/*
	//Open claw, lift, and turn (90 Degrees) all together
	while (SensorValue[in8] <= 580){
		turn(80, 900);
	}
	//Move forward into 3 stars and grab
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	while (SensorValue[grabberEncoder] > grabber(0, 0)) {
			motor[leftGrabber] = 127;
			motor[rightGrabber] = 127;
	}
	motor[leftGrabber] = 0;
	motor[rightGrabber] = 0;
	//Move back (modified back, slowly easing left) and turn left
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, -1);
		motor[leftDrive] = 70;
		motor[leftDrive2] = 70;
	}
	while (SensorValue[in8] <= 580){
		turn(80, 0);
	}
	//Orient to 180 degrees with Gyro
	while (SensorValue[in8] <= 580){
		turn(80, 1800);
	}
	//Move backwards towards fence and throw stars
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, -1);
	}
	//Forward to pick up driver loads x number of times
	//4 Stars, 2 Cubes
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	//From fence orient to gyro 90 degrees
	while (SensorValue[in8] <= 580){
		turn(80, 900);
	}
	//Move forward and pick up 3 stars
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	//Orient to gyro 180 degrees
	//int gyroDir = (1800 - SensorValue[in8])/abs(1800 - SensorValue[in8]);
	while (SensorValue[in8] <= 580){
		turn(80, 1800);
	}
	//Move backwards to fence and throw stars
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, -1);
	}
	//Move forward grab cube
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, 1);
	}
	//Move backwards to fence and throw cube
	while (SensorValue[leftDriveEncoder] <= 580){
		move(60, -1);
	}
	*/
}
